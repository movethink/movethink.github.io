[{"title":"webpack5+vue2打包实践","url":"/2021/03/04/webpack5+vue2打包实践/","content":"\n## 背景\n\n在图转换中间件的开发过程中，需要准备一个开发测试打包一体化环境，该环境至少需要把开发好的中间件代码打包，并上传到我们的私有 npm 仓库中。\n\n中间件代码如下：\n\n<img src=\"http://qiniu.js-5.com/%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%BB%93%E6%9E%84.png\" width=\"250px\" height=\"270px\">\n\n## 准备过程\n\n由于之前的开发测试环境有太多无关代码，现在准备自己重新着手搭建一个纯净的打包环境。优先实现 library（即中间件源码） 文件打包并上传到 npm 中；其次实现本地启动 webpack server，用来作为开发环境调试代码服务器；再次实现本地 vue 项目打包，并放在服务器中可用\n\n## 创建项目\n\n新建一个项目文件夹，起名 test，然后在当前项目目录运行\n\n```js\nnpm init\n```\n\n可以看到当前生成了一个 package.json 文件\n\n然后在当前目录中新建 src 文件夹，用来存放项目代码。并把我们的中间件文件放入其中。现在文件目录是这样的：\n\n<img src=\"http://qiniu.js-5.com/%E5%88%9D%E5%A7%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png\" style=\"max-width:100%\">\n\n## 集成 webpack\n\n### 安装\n\n我们需要把中间件代码打包成一个文件，方便压缩代码和引用等。现在引入 webpack 作为打包工具。由于现在 webpack5 比较新，我们直接安装 webpack5\n\n```js\nnpm install webpack@5 --save-dev\n```\n\n当前初始的 package.json 文件是这样的\n\n```js\n{\n  \"name\": \"test\",\n  \"version\": \"1.0.0\",\n  \"description\": \"test\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [\n    \"test\"\n  ],\n  \"author\": \"guan\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"webpack\": \"^5.24.3\"\n  }\n}\n\n```\n\n### 使用\n\n我们利用 webpack 文件，把一些基本的 webpack 配置写在文件里，然后通过 package.json 中的命令行执行 webpack 命令。\n\n为了试验，我们在 src 目录下新建 index.js 文件，输入测试代码：\n\n```js\nconst test = () => {\n  console.log(\"hello webpack!\");\n};\nexport { test };\n```\n\n在根目录下新建 webpack.config.js 文件，输入以下代码：\n\n```js\nconst path = require(\"path\");\n\nmodule.exports = {\n  mode: \"production\", // 选择模式为生产\n  entry: \"./src/index.js\", // 入口文件\n  output: {\n    filename: \"main.js\", // 出口文件名称\n    library: \"ynChartMiddleware\", // library暴露出来的名称\n    libraryTarget: \"umd\", //在 AMD 或 CommonJS require 之后可访问\n    path: path.resolve(__dirname, \"lib\"),\n  },\n  // 打包代码不压缩\n  optimization: {\n    minimize: false,\n  },\n};\n```\n\n然后在 package.json scripts 字段下加入以下命令：\n\n```js\n    \"build\": \"webpack --config webpack.config.js\"\n```\n\n现在在控制台执行命令：\n\n```js\nnpm run build\n```\n\n控制台报错：\n\n```js\nCLI for webpack must be installed.\n  webpack-cli (https://github.com/webpack/webpack-cli)\n\nWe will use \"npm\" to install the CLI via \"npm install -D webpack-cli\".\nDo you want to install 'webpack-cli' (yes/no):\n```\n\n因为我们想要使用命令行方式调用 webpack 需要首先安装 webpack-cli，所以我们选择安装；再次执行打包命令后得到目标文件（lib/main.js）代码:\n\n```js\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === \"object\" && typeof module === \"object\")\n    module.exports = factory();\n  else if (typeof define === \"function\" && define.amd) define([], factory);\n  else if (typeof exports === \"object\")\n    exports[\"ynChartMiddleware\"] = factory();\n  else root[\"ynChartMiddleware\"] = factory();\n})(self, function () {\n  return /******/ (() => {\n    // webpackBootstrap\n    /******/ \"use strict\"; // The require scope\n   ...\n   // 中间部分省略\n   ...\n    var __webpack_exports__ = {};\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export */ __webpack_require__.d(__webpack_exports__, {\n      /* harmony export */ test: () => /* binding */ test,\n      /* harmony export */\n    });\n    const test = () => {\n      console.log(\"hello webpack!\");\n    };\n\n    /******/ return __webpack_exports__;\n    /******/\n  })();\n});\n```\n\n当前文件目录结构：\n\n<img src=\"http://qiniu.js-5.com/%E6%89%93%E5%8C%85%E6%B5%8B%E8%AF%95.png\" style=\"max-width:100%\">\n\n上图可以看到，我们确实把 src/index.js 文件代码打包成了 lib/main.js\n\n## ES6 转 ES5\n\n在上面的实践中，我们可以看到，虽然我们实现了模块化打包，但是我们发现 webpack 并没有自动进行代码版本转换。\n\n原代码：\n\n```js\nconst test = () => {\n  console.log(\"hello webpack!\");\n};\nexport { test };\n```\n\n打包后：\n\n```js\nreturn /******/ (() => {\n  // webpackBootstrap\n  /******/ \"use strict\"; // The require scope\n  /******/ /******/ var __webpack_require__ = {}; /* webpack/runtime/define property getters */\n  /******/\n  /************************************************************************/\n  /******/ /******/ (() => {\n    /******/ // define getter functions for harmony exports\n    /******/ __webpack_require__.d = (exports, definition) => {\n      /******/ for (var key in definition) {\n        /******/ if (\n          __webpack_require__.o(definition, key) &&\n          !__webpack_require__.o(exports, key)\n        ) {\n          /******/ Object.defineProperty(exports, key, {\n            enumerable: true,\n            get: definition[key],\n          });\n          /******/\n        }\n        /******/\n      }\n      /******/\n    };\n    /******/\n  })(); /* webpack/runtime/hasOwnProperty shorthand */\n  /******/\n  /******/ /******/ (() => {\n    /******/ __webpack_require__.o = (obj, prop) =>\n      Object.prototype.hasOwnProperty.call(obj, prop);\n    /******/\n  })(); /* webpack/runtime/make namespace object */\n  /******/\n  /******/ /******/ (() => {\n    /******/ // define __esModule on exports\n    /******/ __webpack_require__.r = (exports) => {\n      /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n        /******/ Object.defineProperty(exports, Symbol.toStringTag, {\n          value: \"Module\",\n        });\n        /******/\n      }\n      /******/ Object.defineProperty(exports, \"__esModule\", { value: true });\n      /******/\n    };\n    /******/\n  })();\n  /******/\n  /************************************************************************/\n  var __webpack_exports__ = {};\n  __webpack_require__.r(__webpack_exports__);\n  /* harmony export */ __webpack_require__.d(__webpack_exports__, {\n    /* harmony export */ test: () => /* binding */ test,\n    /* harmony export */\n  });\n  const test = () => {\n    console.log(\"hello webpack!\");\n  };\n\n  /******/ return __webpack_exports__;\n  /******/\n})();\n```\n\n这样的代码在 ie11 中无法运行，我们得把 es6 语法编译为 es5。\n\n首先我们把 webpack 自己生成的打包代码变为 es5，这需要再 webpack.config.js 中配置参数：\n\n```js\ntarget: [\"web\", \"es5\"],\n```\n\n该参数意思是打包时编译为类浏览器环境，并按 es5 的风格进行打包。但是这样只会改变 webpack 默认的打包代码，而我们自己的代码任然不会被转码。\n\n因此我们需要引入 babel，来转码我们的 js 文件。先在 webpack 中添加 babel 规则，可以正则检测文件。也可以认为，在 webpack 中使用 babel 就需要使用 babel-loader 来作为连接纽带，用来编译目标文件代码：\n\n```js\nmodule: {\n    rules: [\n      {\n        test: /\\.m?js$/,\n        exclude: /(node_modules)/,\n        use: {\n          loader: \"babel-loader\",\n        },\n      },\n    ],\n  },\n```\n\n我们需要安装 babel-loader 包和 @babel/core 包，并且需要在根目录创建一个 babel 配置文件，文件名为\".babelrc\"，该文件用来告诉 babel 应该如何转码文件，该文件配置如下：\n\n```js\n{\n    \"presets\": [\n        [\n            \"@babel/preset-env\",\n            {\n                \"useBuiltIns\": \"usage\",\n                \"modules\": false,\n                \"corejs\": {\n                    \"version\": 3\n                },\n                \"targets\": {\n                    \"ie\": \"11\"\n                }\n            }\n        ]\n    ]\n}\n```\n\n该文件主要定义了输出的代码版本，以上用到了 @babel/preset-env 用来转换代码，所以我们需要安装它。\n\n现在我们再次执行 build 命令，得到如下编译过后的代码：\n\n```js\nreturn /******/ (function () {\n  // webpackBootstrap\n  /******/ \"use strict\"; // The require scope\n  /******/ /******/ var __webpack_require__ = {}; /* webpack/runtime/define property getters */\n  /******/\n  /************************************************************************/\n  /******/ /******/ !(function () {\n    /******/ // define getter functions for harmony exports\n    /******/ __webpack_require__.d = function (exports, definition) {\n      /******/ for (var key in definition) {\n        /******/ if (\n          __webpack_require__.o(definition, key) &&\n          !__webpack_require__.o(exports, key)\n        ) {\n          /******/ Object.defineProperty(exports, key, {\n            enumerable: true,\n            get: definition[key],\n          });\n          /******/\n        }\n        /******/\n      }\n      /******/\n    };\n    /******/\n  })(); /* webpack/runtime/hasOwnProperty shorthand */\n  /******/\n  /******/ /******/ !(function () {\n    /******/ __webpack_require__.o = function (obj, prop) {\n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    };\n    /******/\n  })(); /* webpack/runtime/make namespace object */\n  /******/\n  /******/ /******/ !(function () {\n    /******/ // define __esModule on exports\n    /******/ __webpack_require__.r = function (exports) {\n      /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n        /******/ Object.defineProperty(exports, Symbol.toStringTag, {\n          value: \"Module\",\n        });\n        /******/\n      }\n      /******/ Object.defineProperty(exports, \"__esModule\", { value: true });\n      /******/\n    };\n    /******/\n  })();\n  /******/\n  /************************************************************************/\n  var __webpack_exports__ = {};\n  __webpack_require__.r(__webpack_exports__);\n  /* harmony export */ __webpack_require__.d(__webpack_exports__, {\n    /* harmony export */ test: function () {\n      return /* binding */ test;\n    },\n    /* harmony export */\n  });\n  var test = function test() {\n    console.log(\"hello webpack!\");\n  };\n\n  /******/ return __webpack_exports__;\n  /******/\n})();\n```\n\n可以看到，我们的代码已经正确的转换了箭头函数，已经把 es6 风格的代码转换成了 es5\n\n综上所述，babel 用来转换代码版本，需要 3 个包：@babel/core babel-loader @babel/preset-env\n\n## 打包中间件\n\n### 打包\n\n现在我们已经用测试文件做好了前期准备，现在我们把 webpack.config.js 中的入口文件改为中间件文件，然后出口文件名改为中间件名。\n\n可以看到报了如下错误：\n\n<img src=\"http://qiniu.js-5.com/corejs%E6%8A%A5%E9%94%99.png\" style=\"max-width:100%\">\n\n这提示我们没有安装 core-js 模块，无法找到对应的转换方法。执行：\n\n```js\ncnpm install core-js --save-dev\n```\n\n再重现 build，发现中间件中使用了 echarts，而我们也需要安装一下 echarts 包；当所有需要用到的包全部安装完毕后，我们可以看到，打包成功了。\n\n### 优化打包大小\n\n我们查看打包文件，代码风格是我们需要的 es5，但是打包文件有 3.5M，这明显太大了，我们需要减小大小。\n\n首先第一步是代码压缩，压缩后大小从 3.5M 变为了 0.9M，明显还是太大了。\n\n我们思考是不是可以不要打包某些包进中间件，比如 echarts。因为中间件宿主环境，也一定会引入 echarts，所以 echarts 可以不用打包进中间件。我们在 webpack 配置文件中加入以下代码：\n\n```js\nexternals: {\n    echarts: {\n      commonjs: \"echarts\",\n      commonjs2: \"echarts\",\n      amd: \"echarts\",\n      root: \"_\",\n    },\n  },\n```\n\n重新打包，我们发现包文件已经变为 66KB，相比于之前的 3.5M，已经小非常多了。现在这个库文件，就已经打包完成了。\n\n## 上传 npm\n\n上传到 npm 中时，包名默认 package.json 中的 name 字段，引用路径默认 main 字段。比如我们把 package.json 改为如下，代表我们包名为 yn-chart-middleware，用户下载包后默认会引用“./lib/yn-chart-middleware.js”目录下的文件。\n\n```js\n{\n  \"name\": \"yn-chart-middleware\",\n  \"version\": \"1.0.0\",\n  \"description\": \"test\",\n  \"main\": \"./lib/yn-chart-middleware.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"build\": \"webpack --config webpack.config.js\"\n  },\n  \"keywords\": [\n    \"test\"\n  ],\n  \"author\": \"guan\",\n  \"license\": \"ISC\",\n  ...\n  ...\n}\n\n```\n\n发布包时先使用 npm login 登录 npm，然后 npm publish 即可发布自己的包\n\n注意：内网环境下，需要先切换 npm 源，然后登录内网 npm。之后的操作和 npm 一致\n\n在有时候，我们不希望自己的开发文件，比如 src/目录下的文件被上传到 npm，我们可以选择不上传这部分文件到 npm 上。如下，在 package.json 中增加如下代码：\n\n```js\n\"files\": [\n\t\t\"lib\"\n\t],\n```\n\n表明只把根目录下 lib 文件夹内容上传到 npm\n\n除了上面的白名单模式，还有黑名单模式（及指定不传的文件，上传所有其他文件）\n\n## 配置代码以及目录结构\n\n目录结构：\n\n<img src=\"http://qiniu.js-5.com/%E5%AE%8C%E6%88%90%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png\" style=\"max-width:100%\">\n\n.babelrc 文件：\n\n```js\n{\n    \"presets\": [\n        [\n            \"@babel/preset-env\",\n            {\n                \"useBuiltIns\": \"usage\",\n                \"modules\": false,\n                \"corejs\": {\n                    \"version\": 3\n                },\n                \"targets\": {\n                    \"ie\": \"11\"\n                }\n            }\n        ]\n    ]\n}\n```\n\nwebpack.config.js 文件：\n\n```js\nconst path = require(\"path\");\n\nmodule.exports = {\n  mode: \"production\", // 选择模式为生产\n  entry: \"./src/yn-chart-middleware/index.js\", // 入口文件\n  output: {\n    filename: \"ynChartMiddleware.js\", // 出口文件名称\n    library: \"ynChartMiddleware\", // library暴露出来的名称\n    libraryTarget: \"umd\", //在 AMD 或 CommonJS require 之后可访问\n    path: path.resolve(__dirname, \"lib\"), // 定义出口文件夹目录\n  },\n  // 打包代码不压缩\n  optimization: {\n    minimize: true,\n  },\n  target: [\"web\", \"es5\"],\n  module: {\n    rules: [\n      {\n        test: /\\.m?js$/,\n        exclude: /(node_modules|bower_components)/,\n        use: {\n          loader: \"babel-loader\",\n        },\n      },\n    ],\n  },\n  // 把以下依赖不打入包中，让包文件去外部宿主中引入这些依赖\n  externals: {\n    echarts: {\n      commonjs: \"echarts\",\n      commonjs2: \"echarts\",\n      amd: \"echarts\",\n      root: \"_\",\n    },\n  },\n};\n```\n\npackage.json 文件：\n\n```js\n{\n  \"name\": \"test\",\n  \"version\": \"1.0.0\",\n  \"description\": \"test\",\n  \"main\": \"index.js\",\n  \"files\": [\n\t\t\"lib\"\n\t],\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"build\": \"webpack --config webpack.config.js\"\n  },\n  \"keywords\": [\n    \"test\"\n  ],\n  \"author\": \"guan\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.13.8\",\n    \"@babel/preset-env\": \"^7.13.9\",\n    \"babel-loader\": \"^8.2.2\",\n    \"core-js\": \"^3.9.1\",\n    \"webpack\": \"^5.24.3\",\n    \"webpack-cli\": \"^4.5.0\"\n  },\n  \"dependencies\": {\n    \"echarts\": \"^5.0.2\",\n    \"number-precision\": \"^1.5.0\"\n  }\n}\n\n```\n\n## 集成 vue\n\n用于直接在该环境上开发测试中间件\n\nto do.\n\n## 参考资料\n\n[webpack 手册](https://webpack.docschina.org/guides/production/)\n","tags":["js","webpack","vue"]},{"title":"js浮点数运算精度问题","url":"/2020/08/14/js浮点数运算精度问题/","content":"\n## 问题提出\n\n```js\n10.23 + 0.2345;\n0.1 + 0.2;\n```\n\n10.23 + 0.2345 实际测试结果为`10.464500000000001`,而不是`10.4645`\n0.1 +0.2 实际测试结果为`0.30000000000000004`,而不是`0.3`\n\n## 原因\n\n浮点数在 2 进制中存储的时候，无法精确存储\n\njs 在数据存储中采用 64 位双精度浮点数形式储存\n\n## 整数转为 2 进制\n\n用 8 位 2 进制表达 10 进制下的数字 8\n\n```js\n8/2 = 4 => 0\n4/2 = 2 => 0\n2/2 = 1 => 0\n1/2 = 0 => 1\n```\n\n商为 0 终止计算，然后倒排为 1000，因为是 8 位，所以在上 4 位补 0\n表达即为：00001000\n\n## 浮点数转换为 2 进制\n\n例如 0.82 的二进制表达为：\n\n```js\n0.82 _ 2 = 1.64 => 1\n0.64 _ 2 = 1.28 => 1\n0.28 _ 2 = 0.56 => 0\n0.56 _ 2 = 1.12 => 1\n0.12 _ 2 = 0.24 => 0\n0.24 _ 2 = 0.48 => 0\n0.48 _ 2 = 0.96 => 0\n0.96 _ 2 = 1.92 => 1\n```\n\n表达即为：0.11010001...\n\n举例：10 进制下 0.1 表达为二进制下为：0.000110011...\n\n## 浮点数在 64 位双精度下的存储\n\n符号位 S：第 1 位是正负数符号位（sign），0 代表正数，1 代表负数\n\n指数位 E：中间的 11 位存储指数（exponent），用来表示次方数\n\n尾数位 M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零\n\n![](https://camo.githubusercontent.com/af8c1cdd9aedced18be47e40d27208b671b4a18d/687474703a2f2f617461322d696d672e636e2d68616e677a686f752e696d672d7075622e616c6979756e2d696e632e636f6d2f37323637613538623239383932633362373233653364366333663733393035612e706e67)\n\n公式表示：\n\n![](https://user-images.githubusercontent.com/948896/31601625-1f199ad0-b220-11e7-9d46-bb48a470bedf.png)\n\n以上的公式遵循科学计数法的规范，在十进制是为 0<M<10，到二进行就是 0<M<2。也就是说整数部分只能是 1，所以可以被舍去，只保留后面的小数部分。如 4.5 转换成二进制就是 100.1，科学计数法表示是 1.001\\*2^2，舍去 1 后 M = 001。E 是一个无符号整数，因为长度是 11 位，取值范围是 0~2047。但是科学计数法中的指数是可以为负数的，所以再减去一个中间数 1023，[0,1022]表示为负，[1024,2047] 表示为正。如 4.5 的指数 E = 1025，尾数 M 为 001\n\n![](https://user-images.githubusercontent.com/948896/31601584-f65ed43e-b21f-11e7-8755-c99b48e5134c.png)\n\n0.1 转成二进制表示为 0.0001100110011001100(1100 循环)，1.100110011001100x2^-4，所以 E=-4+1023=1019；M 舍去首位的 1，得到 100110011...\n\n0.1 +0.2\n\n```js\n// 0.1 和 0.2 都转化成二进制后再进行运算\n0.0001100110011001100110011001100110011001100110011001101 +\n0.001100110011001100110011001100110011001100110011001101 = 0.0100110011001100110011001100110011001100110011001100111;\n\n// 转成十进制正好是 0.30000000000000004\n```\n\n## 生产环境中的解决办法\n\nhttps://github.com/dt-fe/number-precision\n","tags":["js"]},{"title":"树遍历","url":"/2020/08/08/树遍历/","content":"\n## js 中关于树的一些操作\n\n### 树的遍历与查找\n\n一般通过递归的方式遍历一颗树\n一般遍历一棵树是为了查找里面的元素，比较保险的方法是先遍历树，保存为一个数组，然后再通过 array.find 方法查找元素\n\n```js\n/**\n * 根据id在tree获取相对应的item\n * @param tree 搜索的tree对象，类型{}\n * @param id 需要搜索的item对应的id\n * @memberof TreeSearch\n */\nfindItemInTree = (tree, id) => {\n  let list = [];\n  // 遍历tree，存储到list\n  const loop = (tree) => {\n    if (tree == null) {\n      return;\n    }\n    list.push(tree);\n    if (tree.children && tree.children.length > 0) {\n      for (let i = 0; i < tree.children.length; i++) {\n        loop(tree.children[i]);\n      }\n    }\n  };\n  loop(tree);\n  let item = list.find((listItem) => {\n    return listItem.id === id;\n  });\n  return item;\n};\n```\n\n### 获取元素 path\n\n一般我们还有一个需求，就是获取树的 path\n可以遍历树，存储为一个键值对结构，比如{}或者 map，然后再通过 parentId 直接循环查找，获取 path 数组\n\n```js\n/**\n * 根据id获得item在tree中的路径\n *  @param tree tree对象\n *  @param id item对应的id\n * @memberof TreeSearch\n */\nfindItemPath = (tree, id) => {\n  let listMap = new Map();\n  // 遍历tree，存储到listMap\n  const loop = (tree) => {\n    if (tree == null) {\n      return;\n    }\n    listMap.set(tree.id, tree);\n    if (tree.children && tree.children.length > 0) {\n      for (let i = 0; i < tree.children.length; i++) {\n        loop(tree.children[i]);\n      }\n    }\n  };\n  loop(tree);\n  let path = [];\n  let currentNodeId = id;\n  // 根节点上没有parentId字段，所以直接循环得出path数组\n  while (currentNodeId) {\n    path.unshift(currentNodeId);\n    currentNodeId = listMap.get(currentNodeId).parentId;\n  }\n  return path;\n};\n```\n\n### 树的遍历方式\n\n#### 深度优先\n\n```js\ntest = () => {\n  let tree = {\n    key: 1,\n    value: 1,\n    children: [\n      {\n        key: 2,\n        value: 2,\n        children: [\n          {\n            key: 4,\n            value: 4,\n          },\n          {\n            key: 5,\n            value: 5,\n          },\n        ],\n      },\n      {\n        key: 3,\n        value: 3,\n        children: [\n          {\n            key: 6,\n            value: 6,\n          },\n          {\n            key: 7,\n            value: 7,\n          },\n        ],\n      },\n    ],\n  };\n  console.log(tree, \"tree\");\n  // 递归方式\n  const DFS = (tree) => {\n    let list = [];\n    const loop = (tree) => {\n      list.push(tree);\n      if (tree.children && tree.children.length > 0) {\n        for (let i = 0; i < tree.children.length; i++) {\n          loop(tree.children[i]);\n        }\n      }\n    };\n    loop(tree);\n    return list;\n  };\n  let array = DFS(tree);\n  console.log(array, \"array\");\n};\n```\n\n#### 广度优先\n\n```js\n// 非递归方式\nconst BFS = (tree) => {\n  let list = [];\n  if (tree !== null) {\n    // 借用队列实现，队列先进先出，借用数组模拟队列\n    let queue = [];\n    queue.unshift(tree);\n    while (queue.length !== 0) {\n      let item = queue.shift();\n      list.push(item);\n      let children = item.children;\n      if (children) {\n        for (let i = 0; i < children.length; i++) {\n          queue.push(children[i]);\n        }\n      }\n    }\n  }\n  return list;\n};\n\nlet array2 = BFS(tree);\nconsole.log(array2, \"array2\");\n```\n","tags":["js"]}]