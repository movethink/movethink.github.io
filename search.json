[{"title":"游戏加速器基本知识","url":"/2025/03/12/游戏加速器基本原理/","content":"\n# 为什么需要加速器\n\n- GFW\n\n由于 GFW 的存在，导致跨境流量有一个总的出口；而跨境流量大小有限制（需要审核），而其他跨境流量拥有比游戏数据（udp）更高的优先级，因此导致游戏数据更容易丢包。\n\n- 物理距离\n\n和游戏服务器物理距离太远，路由转发过程漫长\n\n- 运营商网络优化策略以及跨网转发效率等问题\n\n国内不同运营商（电信、联通、移动）之间的跨网传输效率低，加速器通过多节点覆盖缓解此问题。\n\n# 游戏服务器连接方式\n\n这时就需要游戏加速器，优化一般以下两种\n\n- 中转节点\n\n游戏加速器一般在香港或者日本构建跳板服务器，该服务器用 udp 直连游戏服务器，而加速器一般通过 tcp 伪装等方式连游戏服务器。\n\n- 协议优化\n\n针对 udp 协议，通过冗余传输、数据包纠错等方式减少丢包率\n\n针对 tcp 协议，优化三次握手，减少链接耗时\n\n- 动态路由选择\n\n定时检测网络好的节点，切换到网络好的节点进行传输\n\n- 数据压缩以及流量控制\n\n压缩语音、贴图等非关键数据\n\n优先发送操作指令，比如人物移动指令、攻击动作等\n\n# 加速器基本原理\n\n玩家设备 → 加速器客户端 → 中转服务器（优化路径） → 游戏服务器\n（协议优化、加密） （动态路由、数据压缩）\n\n# 加速器的限制\n\n- 物理距离无法消除，无法突破光速限制（路由链路过长等问题）\n\n- 依赖线路质量（线路堵塞等）\n\n- 协议兼容性问题（有些游戏采用特殊协议，比如 p2p，加速器无法优化）\n\n# 跨国大型游戏如何保证链接质量\n\n一般在游戏所在国建立中转服务器\n\n# 未来展望\n\n在可预见的未来，因为 GFW 的存在，游戏加速器可能还会长期存在\n","tags":["js"]},{"title":"防抖与节流","url":"/2022/11/07/防抖与节流/","content":"\n## 定义\n\n- 节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效\n\n- 防抖: n 秒后再执行该事件，若在 n 秒内被重复触发，则重新计时\n\n是一种性能优化手段，比如浏览器的 scroll 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地影响性能\n\n## 实现\n\n#### 防抖\n\n```js\nconst debounce1: Function = (fun: Function, time: number) => {\n  let curTimer: any;\n  return function () {\n    clearTimeout(curTimer);\n    curTimer = setTimeout(() => {\n      fun();\n    }, time);\n  };\n};\n```\n\n#### 节流\n\n使用时间戳方式实现\n\n```js\n/**\n * 先执行函数再节流\n * @param fun\n * @param time\n */\nconst throttled: Function = (fun: Function, time: number) => {\n  let curTime = getTime();\n  return function () {\n    let newTime = getTime();\n    if (newTime - curTime >= time) {\n      fun();\n      curTime = getTime();\n    }\n  };\n};\n```\n\n使用 setTimeout 实现\n\n```js\n/**\n * 先执行节流后执行函数\n * @param fun\n * @param time\n */\nconst throttled2: Function = (fun: Function, time: number) => {\n  let curTimer: any;\n  return function () {\n    if (!curTimer) {\n      curTimer = setTimeout(() => {\n        fun();\n        curTimer = null;\n      }, time);\n    }\n  };\n};\n```\n\n以上都是最简单的实现，如果需要传参或者执行上下文，可以传入 this 和 arguments 对象，举例如下：\n\n```js\nconst throttled2: Function = (fun: Function, time: number) => {\n  let curTimer: any;\n  return function () {\n    let context = this;\n    let params = arguments;\n    if (!curTimer) {\n      curTimer = setTimeout(() => {\n        fun.apply(context, arguments);\n        curTimer = null;\n      }, time);\n    }\n  };\n};\n```\n\n## 区别\n\n相同点\n\n- 都是为了降低回调执行次数，优化性能\n\n不同点\n\n- 节流是把一段连续高频操作降频，在时间段内均匀分割执行若干次。\n\n- 防抖是把一段连续高频操作合并，在时间段内只执行一次\n\n## 应用场景\n\n节流\n\n- 滚动加载，加载更多或滚到底部监听\n\n- 画布组件拖入时的事件回调\n\n防抖\n\n- 搜索框搜索输入\n\n- 组件调整大小时，图需要重新自适应加载\n","tags":["js"]},{"title":"结合webpack删除项目冗余文件","url":"/2022/03/25/结合webpack删除项目冗余文件/","content":"\n## 背景\n\n项目中有许多冗余文件，非常影响项目大小，因此需要删除不需要的文件\n\n## 思考\n\n手动删除非常麻烦并且无法保证清除效果，因此想办法找出某种规律批量删除。\n\n前端项目一般使用 webpack 打包，打包的过程中 webpack 会根据入口文件遍历出所有文件，因此可以利用 webpack 来确定项目中哪些文件可用。而项目中的所有文件可以通过 nodejs 得到，因此可以通过 webpack 和 nodejs 做文件对比，然后自动清除未被编译引用的文件，思路如下：\n\n1.在项目 webpack 编译时，会从入口处自动遍历需要的文件，并且在编译过程中，会形成一个 stats.json 文件，用来展示这种引用关系。\n\n2.我们可以从 stats.json 中得到所有编译需要的文件的原始路径\n\n3.我们可以得到项目中所有的文件的原始路径\n\n4.我们可以通过对比两边的路径，从而得到未被编译的文件的路径\n\n5.我们可以通过 shelljs 包，通过命令行删除该未被引用的路径文件\n\n## 实现\n\n#### 获取编译文件\n\n在 webpack 执行时，我们可以在 webpack 命令后加上`--profile --json > stats.json`，这样就会最终的输出目录，额外输出一个`stats.json`文件，里面记录了 webpack 执行的一些 log 信息，或者执行过程等信息。比如：\n\n```json\n\"ana\": \"webpack --config webpack.prod.js --profile --json > stats.json\"\n```\n\n通过`npm run ana`命令执行后，即可在 webpack 命令执行输出目录额外输出`stats.json`文件。\n\n在 vue cli 中，因为其内部集成了`webpack-bundle-analyzer`分析工具，所以我们可以使用以下命令获得`stats.json`文件\n\n```json\n\"build:ana\": \"vue-cli-service build '--report-json'\",\n```\n\n获得`stats.json`文件后，通过 fs 模块读取内容。如果文件过大（超过 512M）那么需要使用文件流读取内容：\n\n```js\nlet chunkList = [];\nlet list = [];\nlet stream = fs.createReadStream(statPath, {\n  encoding: \"utf8\",\n});\nconst parser = JSONStream.parse(\"modules.*\");\nstream.pipe(parser);\nparser.on(\"data\", (data) => {\n  chunkList = chunkList.concat(data);\n});\nparser.end(\"data\", (data) => {\n  chunkList = chunkList.map((item) => {\n    return {\n      name: item.name,\n      modules: item.modules,\n      id: item.id,\n    };\n  });\n  // todo\n});\n```\n\n#### 获取全部文件\n\n我们通过 glob 模块，获得项目指定目录下的所有文件。\n\n```js\nfunction getAllFilesInSrc() {\n  const pattern = \"./src/**\";\n\n  return new Promise((resolve, reject) => {\n    glob(\n      pattern,\n      {\n        nodir: true,\n      },\n      (err, files) => {\n        resolve(files);\n      }\n    );\n  });\n}\n```\n\n#### 获取待删除文件\n\n我们直接通过对比所有文件和编译文件，来获得待删除文件（未被编译的文件）\n\n```js\n// allFile 所有文件数组\n// compileFile 被编译使用的文件数组\n// unFiles 需要被删除的文件数组\nlet unFiles = allFile.filter((item) => compileFile.indexOf(item) < 0);\n```\n\n#### 删除文件\n\n得到待删除文件数组后，我们遍历删除文件即可：\n\n```js\nunFiles.forEach((file) => {\n  console.log(\"已删除文件：\" + file);\n  shelljs.rm(file);\n});\nconsole.log(\"合计删除文件个数：\" + unFiles.length);\n```\n\n## 遇到的问题\n\n1.dashboard 通过设计态和运行态分两次打包，因此需要分析两份 stats.json（解决）\n\n2.设计态生成的 stats.json 过于巨大（590M)，超过了 nodejs 能默认处理的数据上限（512M）：\n采用 JSONStream 模块，通过创建文件流，使用 JSONStream 解析文件流，解决该问题\n\n3.文件解析不准确问题\n例如'./src/components/charts/yn-echart-bar-dt/index.js'文件用到了，但是没有被统计到编译文件中\n\n该文件结构类似于：\n\n```js\n{\n  \"modules\": [\n    {\n    ...,\n    name: \"xxx\",\n    ...,\n    \"modules\": [\n      {\n      ...,\n      name: \"xxx\",\n      ...,\n      }\n    ]}\n  ]\n}\n```\n\n我们需要读取 modules 数组，如果下层对象中存在 modules 属性，说明该对象是聚合来的，需要把当前 modules 属性迭代出来，加入到编译文件数组中（这里需要递归迭代），这样我们就能拿到全量的编译文件了。\n\n4.修复误删文件，后来直接添加了忽略列表，用来存放需要忽略删除的文件\n\n## 参考文档\n\n[利用 webpack 分析和删除冗余文件](https://github.com/ginobilee/blog/issues/10)\n[包含统计数据的文件(stats data)](https://www.webpackjs.com/api/stats/#asset-objects)\n","tags":["js"]},{"title":"事件循环","url":"/2022/01/19/事件循环/","content":"\n## 浏览器线程\n\n按照谷歌浏览器来说，其一个 tab 页签是一个进程，每个进程中存在多个线程\n\n进程：资源分配的最小单位\n\n线程：程序执行的最小单位\n\n常见的浏览器线程包括以下几种：\n\n- GUI 线程，当需要渲染 html 页面或者重绘页面时，该线程就会执行。\n\n- js 线程，用来执行 js，一直等待着任务队列中的任务到来，然后解析 js 脚本，执行代码。一个进程中永远只有一个 js 线程在运行 js 程序。当 js 线程活跃时，会中断 GUI 线程，该线程和 GUI 线程是互斥运行的。\n\n- 定时器线程，当 setTImeOut 和 setInterval 被调用时，会被专门的定时器线程处理。当计数完成后，其回调函数会被加入任务队列末尾，等待 js 引擎处理\n\n- http 网络服务线程，用来处理 http 请求等。当请求完成有回调函数时，会把该回调函数加入任务队列末尾，等待 js 引擎处理。\n\n- 事件处理线程，demo 中的每一个事件被触发，都会起一个被浏览器事件处理线程处理。当事件被触发时，会把事件函数加入任务队列末尾，等待 js 引擎处理\n\n## 任务\n\n一般分为同步任务和异步任务，js 主线程直接执行同步任务，异步任务会进入任务队列中，任务队列主要分为两种，即宏任务队列和微任务队列\n\n### 宏任务\n\n一般的 setTimeOut，setInterval，script 主文件，ajax 请求的回调函数，I/O 操作等都属于宏任务\n\n### 微任务\n\n一般 premise 的 then 回调，process.nextTikc()等属于微任务\n\n## 事件循环\n\n在 js 遇到 script，把它放在宏任务队列中。在解析的过程中，遇到同步代码，会顺序执行。遇到异步代码，则判断是宏任务还是微任务，宏任务放在宏任务队列的末尾，微任务放到微任务末尾。\n\n当一个宏任务执行完成后，会立即执行微任务队列中的微任务。微任务中产生的宏任务或微任务，按之前的方式分别放置在对应队列中。只有当前微任务队列中的所有微任务全部执行完成后，才会执行下一个宏任务。\n\n这个循环执行的过程，就是事件循环。当所有任务执行完毕后，js 线程会等待任务队列中任务的到来，一旦有新任务到来，则继续重复以上动作。\n\n## 例子\n\n```js\nnew Promise((resolve) => {\n  setTimeout(() => {\n    console.log(666);\n    new Promise((resolve) => {\n      resolve();\n    }).then(() => {\n      console.log(777);\n    });\n  });\n  resolve();\n})\n  .then(() => {\n    new Promise((resolve) => {\n      resolve();\n    })\n      .then(() => {\n        console.log(111);\n      })\n      .then(() => {\n        console.log(222);\n      });\n  })\n  .then(() => {\n    new Promise((resolve) => {\n      resolve();\n    })\n      .then(() => {\n        new Promise((resolve) => {\n          resolve();\n        }).then(() => {\n          console.log(444);\n        });\n      })\n      .then(() => {\n        console.log(555);\n      });\n  })\n  .then(() => {\n    console.log(333);\n  });\n```\n\n输出：\n111,222,333,444,555,666,777\n","tags":["js"]},{"title":"class与function","url":"/2021/12/13/class与function/","content":"\n## 实现继承\n\n本篇博文想到哪就写到哪~\n\njs 里需要用到继承的场景，一般是需要自己通过构造函数创建对象的时候，这个对象有自己特别的一些方法，并且可以被标识为特定的类型。这时候我们通常会使用构造函数创建对象，并且可以通过继承实现代码扩展。\n\n## function 实现\n\n在 ES5 中，我们一般通过原型链继承，一般会通过构造函数实现\n\n```js\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\nPerson.prototype.sayHello = function () {\n  console.log(\"my name is \", this.name);\n};\nlet person1 = new Person(\"guan\", \"2\");\nlet person2 = new Person(\"jie\", \"3\");\n```\n\n在实例化的过程中，person1 和 person2 均拥有 sayHello 方法。一般构造函数，命名时首字母大写。\n\n## class 实现\n\n在 ES6 中，实现了 class 定义方式，可以简单理解为 class 就是之前 function 实现继承方式的语法糖：\n\n```js\nclass Person = {\n  constructor(name,age){\n    this.name = name;\n    this.age = age;\n  }\n  sayHello(){\n    console.log(\"my name is \", this.name)\n  }\n}\nlet person1 = new Person(\"guan\", \"2\");\nlet person2 = new Person(\"jie\", \"3\");\n```\n\n## new 操作\n\nnew 本质上做了 4 件事\n新建一个对象\n把这个对象的原型指向 new 的那个构造函数或者类\n将新建的对象作为 this 的上下文\n返回一个构造函数的返回值，如果没有返回值，则返回 this\n\n## call\n\ncall() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。\n\ncall 最大的作用用来指定函数的上下文执行环境\n\n```js\nfunction greet() {\n  var reply = [this.animal, \"typically sleep between\", this.sleepDuration].join(\n    \" \"\n  );\n  console.log(reply);\n}\n\nvar obj = {\n  animal: \"cats\",\n  sleepDuration: \"12 and 16 hours\",\n};\n\ngreet.call(obj); // cats typically sleep between 12 and 16 hours\n```\n\n当第一个参数不传时默认指向 window 对象，严格模式下指向 undefined\n\n第一个参数为一个对象。\n\n可以认为“js 中一切皆对象”，对象是拥有属性和方法的数据。 js 共有 7 中基本类型的（number，string，boolean，null，undefined，symbol，object ），之所以它们可以像对象一样引用，只是因为在引用过程中发生了“临时包装”导致，实际上，“js 中一切皆对象”是不准确的。\n\nsymbol 也是一个基础类型，主要作用于生成一个唯一的值\n\n比如在枚举场景中：\n\n```js\nconst COLOR_GREEN = Symbol(\"green\");\nconst COLOR_RED = Symbol(\"red\");\nSymbol(\"green\") === Symbol(\"green\"); // false\n```\n\n就算 green 和 red 为同一字符都不会影响后面的判断逻辑\n","tags":["js"]},{"title":"webpack支持ie11","url":"/2021/12/03/webpack支持ie11/","content":"\n## 准备\n\n对于某些项目来说，是有 ie11 支持需求的，一般 to b 的业务，得优先考虑是否需要支持 ie。对于 vue 项目而言，一般分为 webpack 集成 vue，和使用 vue cli 搭建。个人倾向于使用 webpack 集成 vue 的方式，这样遇到问题更容易有解决方案。vue cli 在 webpack 上封装了一层，使用起来还是有点束缚，当然，一般的支持 vue cli 还是支持度很高的。如果是高度自定义化的项目，个人喜欢用 webpack 集成 vue。\n\n## 编译\n\n首先需要借助 babel，来把 es6 代码编译为 es5，通常会借助 babel-loader 实现，比如在项目中引入`babel.config.json`，通常格式如下：\n\n```json\n{\n  \"presets\": [\n    [\n      \"@babel/preset-env\"\n      // 设置plugins后可以不写这个配置项，免得重复打包增加包大小\n      // 这是core-js3用法，因为p1包的限制，项目整体只能使用corejs2\n      // {\n      //     \"useBuiltIns\": \"entry\",\n      //     \"corejs\": {\n      //         \"version\": 3\n      //     },\n      //     \"targets\": {\n      //         \"ie\": \"11\"\n      //     }\n      // }\n    ]\n  ],\n  \"plugins\": [\n    // corejs3用法\n    // [\n    //     \"@babel/plugin-transform-runtime\",\n    //     {\n    //         \"corejs\": {\n    //             \"version\": 3,\n    //             \"proposals\": true\n    //         },\n    //         \"useESModules\": true\n    //     }\n    // ]\n  ]\n}\n```\n\n配置好 babel 配置文件后，我们需要在 webpack.config.js 文件中运用 loader 规则：\n\n```js\nmodule: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\"style-loader\", \"css-loader\"],\n      },\n      {\n        test: /\\.vue$/,\n        use: [{ loader: \"vue-loader\" }],\n      },\n      {\n        test: /\\.svg/,\n        use: [\"file-loader\"],\n      },\n      {\n        test: /\\.html$/,\n        use: [\"html-loader\"],\n      },\n      {\n        test: /\\.m?js$/,\n        exclude: /(node_modules|bower_components)/, //排除node_modules中的文件\n        use: {\n          loader: \"babel-loader\",\n        },\n      },\n    ],\n  },\n```\n\n这样项目中的 js 文件就会从 es6 编译为 es5 代码。\n\n有些库默认不支持 es5，他们编译在 node_modules 中的代码就是 es6 的语法，比如使用了一些箭头函数之类的语法，这时候需要单独在 webpack 中为其配置转换规则：\n\n```js\nmodule: {\n    rules: [\n      {\n        test: /\\.m?js$/,\n        exclude: /(node_modules|bower_components)/, //排除node_modules中的文件\n        include: [\n          resolve(\"../node_modules/react-loadable\"),\n          resolve(\"../src\"),\n          resolve(\"./router.config.js\")\n        ],\n        use: {\n          loader: \"babel-loader\",\n        },\n      },\n    ],\n  },\n```\n\n需要注意的是，以上写法仅仅支持 babel7 以上，并且 babel 配置文件需要是`babel.config.json`，而不能是简写的`.babelrc`形式，因为`.babelrc`作为配置文件的时候默认不会编译`node_modules`文件夹中的代码。\n\n## polyfill\n\nbabel-loader 只能把 es6 代码编译为 es5 代码，但是还有一些 es6 中的新 api，是无法转换的，需要提供合适的“垫片”----polyfill，简单来说，就是把新的 api 用老的方式实现以下，因为低级浏览器中无法识别这些新 api，比如 promise 函数在 ie11 中就无法支持，需要有合适的 polyfill 才能识别。\n\n### webpack + vue\n\n我们一般使用 vue 来加速前端代码构建，这里例举如何在 webpack 中直接集成 vue 项目，并使得项目支持 ie11.\n\n关于 webpack 如何集成 vue，可以查看之前的文章，在此不再赘述。\n\n#### core-js2\n\ncore-js2 方式中，一般需要安装`@babel/polyfill`包，可以直接通过 npm 方式安装。因为 polyfill 会在源代码安装前运行，所以需要安装成 dependencies 而不是 devDependencies，安装`@babel/polyfill`包后，把该包引入 main.js 文件（入口文件）即，除此以外，还需要在 webpack 的入口文件处加上如下配置：\n\n```js\nconfig.entry(\"main\").add(\"@babel/polyfill\");\n```\n\n其实很多情况下，只要在 main.js 下首行引入 polyfill 即可\n\n```js\nimport \"@babel/polyfill\";\n```\n\n但是这种方式会全量引入 polyfill，对于不好排查新 api，并且比较大的项目，可以使用这种方式，大而全。\n\n#### core-js3\n\ncore-js3 会支持很多 2 中没有的 api，并且配置相对来说更加方便，只需要在 babel.config.js 中这样配置就行：\n\n```js\n{\n    \"presets\": [\n        [\n            \"@babel/preset-env\",\n            // 设置plugins后可以不写这个配置项，免得重复打包增加包大小\n            {\n                \"useBuiltIns\": \"entry\",\n                \"corejs\": {\n                    \"version\": 3\n                },\n                \"targets\": {\n                    \"ie\": \"11\"\n                }\n            }\n        ]\n    ],\n    \"plugins\": [\n        // corejs3用法\n        [\n            \"@babel/plugin-transform-runtime\",\n            {\n                \"corejs\": {\n                    \"version\": 3,\n                    \"proposals\": true\n                },\n                \"useESModules\": true\n            }\n        ]\n    ]\n}\n```\n\n并且可以实现 polyfill 的按需加载。\n\n### vue cli\n\n为什么会有 core-js2 和 core-js3 的方式呢？是因为某些项目中有些包限制，之前的版本可能是基于 core-js2 构建，所有这种情况下只能选择 core-js2。\n\n当使用 vue cli 构建时，cli3 基于 core-js2;cli3 以上基于 core-js3,因此不同的 vue cli 版本也会有不同的处理。一般来说，在 babel.config.js 中，会这样编写：\n\n```js\nmodule.exports = {\n  presets: [\n    // [\n    //   \"@babel/preset-env\",\n    //   // 设置plugins后可以不写这个配置项，免得重复打包增加包大小\n    //   // webpack直接集成vue方式\n    //   {\n    //     useBuiltIns: \"entry\"\n    //   }\n    // ],\n    // [\n    //   \"@babel/preset-react\",\n    //   {\n    //     throwIfNamespace: false\n    //   }\n    // ],\n    // vue cli方式\n    [\n      \"@vue/app\",\n      {\n        // polyfills: [\n        //   \"es6.promise\",\n        //   \"es6.symbol\",\n        //   \"es6.string.includes\",\n        //   \"es7.array.includes\",\n        //   \"es6.string.repeat\"\n        // ]\n        useBuiltIns: \"entry\",\n      },\n    ],\n  ],\n  plugins: [\n    // [\"@babel/plugin-proposal-class-properties\"],\n    [\n      \"import\",\n      { libraryName: \"ant-design-vue\", libraryDirectory: \"es\", style: \"css\" },\n    ],\n    [\n      \"import\",\n      {\n        libraryName: \"vant\",\n        libraryDirectory: \"es\",\n        style: true,\n      },\n      \"vant\",\n    ],\n  ],\n};\n```\n\n如果是 cli3 以上的版本，则可以通过如下配置来实现：\n\n```js\nmodule.exports = {\n  presets: [\n    [\n      \"@vue/app\",\n      {\n        polyfills: [\"es.promise\", \"es.symbol\"],\n      },\n    ],\n  ],\n};\n```\n\n在上面两种方式中，均可以在 package.json 中定义目标浏览器`browserslist`，该值会被`@babel/preset-env`读取到，用来确定需要转译的 js 特性，比如在 package.json 中我们可以这样定义：\n\n```json\n\"browserslist\": [\n    \"> 1%\",\n    \"last 2 versions\"\n  ],\n```\n\n在 vue cli 中，默认情况下 babel-loader 会忽略所有 node_modules 中的文件。如果你想要通过 Babel 显式转译一个依赖，可以在`transpileDependencies`选项中列出来,比如`@antv/g6`默认支持 es6，如果我们项目中有依赖该库，那就只能在 vue.config.js 文件的`transpileDependencies`字段中指定：\n\n```js\nmodule.exports = {\n  transpileDependencies: [\"@antv/g6\"],\n};\n```\n\n当没有使用 vue cli 时，我们可以像上文中所诉,在 webpack.config.js 中通过`include`字段定义：\n\n```js\nmodule: {\n    rules: [\n      {\n        test: /\\.m?js$/,\n        exclude: /(node_modules|bower_components)/, //排除node_modules中的文件\n        include: [\n          resolve(\"../node_modules/react-loadable\"),\n          resolve(\"../src\"),\n          resolve(\"./router.config.js\")\n        ],\n        use: {\n          loader: \"babel-loader\",\n        },\n      },\n    ],\n  },\n```\n","tags":["js"]},{"title":"闭包","url":"/2021/10/14/闭包/","content":"\n## 定义\n\n当一个函数访问了函数外定义的变量（对于该函数来说，是一个自由变量；函数内定义的变量叫做约束变量），就形成了一个广义上的闭包。\n\n而 js 中的闭包，一般是指在函数外访问到了函数内部作用域的变量，那么这种情况就叫做闭包（实际上更像是闭包的一种应用）\n\n## 产生条件\n\n在 js 中，如果要产生闭包，需要 1 个条件：\n\n当前作用域存在指向父作用域的引用\n\n理解为：上级作用域变量的生命周期，因为被下级作用域引用时，而没有被释放。导致上级作用域内变量，等到下级作用域执行完成后才得到正常的释放。\n\n## 例子\n\n```js\nfunction outer() {\n  var a = 1;\n  return function inner() {\n    a = a + 1;\n    console.log(\"a=\", a);\n  };\n}\nlet A = outer();\nA(); // a= 2\nA(); // a= 3\nA(); // a= 4\n```\n\n当 outer 执行后，outer 函数内部的变量应该全部被销毁。但是因为 outer 返回了一个内部函数，而该内部函数引用了父作用域中的一个变量，因此当该函数被返回时，该函数执行时的作用域也被拷贝了一份存入内存中。使得执行函数 A 时，能通过内部函数 inner 访问到 outer 函数内部的变量 a。\n\n## 一个比喻\n\n通俗地讲就是别人家有某个东西，你想拿到但是因为权限不够（不打死你才怪），但是你可以跟家里的孩子套近乎，通过他拿到！\n这个家就是局部作用域，外部无法访问内部变量，孩子是返回对象，对家里的东西有访问权限，借助返回对象间接访问内部变量！\n\n## 参考：\n\n[闭包的解释](https://www.zhihu.com/question/34210214)\n","tags":["js"]},{"title":"webpack打包优化","url":"/2021/08/06/webpack打包优化/","content":"\n## 主要原因\n在项目中，我们发现打包出来的源码比较庞大，并且引用关系十分混乱，具体表现在：\n + 引用多个版本的包\n + 项目中存在很多冗余文件\n + 项目中引用了无用的包\n + 多打包入口导致包重复引用\n\n## 分析辅助工具\n有一个npm工具包，叫做`webpack-bundle-analyzer`，安装后可以启动一个打包分析界面。\n具体在webpack.config.js中配置：\n```js\nconst BundleAnalyzerPlugin = require(\"webpack-bundle-analyzer\")\n  .BundleAnalyzerPlugin;\nmodule.exports = {\n  // devtool: \"source-map\",\n  plugins: [\n    // 打包构成分析器\n    new BundleAnalyzerPlugin(),\n    // 默认配置的具体配置项\n    // new BundleAnalyzerPlugin({\n    //   analyzerMode: 'server',\n    //   analyzerHost: '127.0.0.1',\n    //   analyzerPort: '8888',\n    //   reportFilename: 'report.html',\n    //   defaultSizes: 'parsed',\n    //   openAnalyzer: true,\n    //   generateStatsFile: false,\n    //   statsFilename: 'stats.json',\n    //   statsOptions: null,\n    //   excludeAssets: null,\n    //   logLevel: info\n    // })\n  ],\n};\n```\n执行npm命令时，会自动打开起分析页面，界面类似：\n![](http://qiniu.js-5.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210806142838.png)\n\n## 多入口打包交叉引用问题\n比如有这样几个文件，均在`./src/bundle-test`目录下：\na.js\n```js\nconst a = () => {\n  console.log(\"isA\");\n  console.log(c());\n};\nimport c from \"./c\";\nconst vue = require(\"vue\");\n\nexport default a;\n```\nb.js\n```js\nconst b = () => {\n  console.log(\"isB\");\n  console.log(c());\n};\n\nimport c from \"./c\";\nconst vue = require(\"vue\");\n\nexport default b;\n```\nc.js\n```js\nconst c = () => {\n  console.log(\"isC\");\n};\n\nexport default c;\n```\nindex.js\n```js\nimport A from \"./a.js\";\nimport B from \"./b.js\";\n\nconst test = () => {\n  console.log(\"isI\");\n  A();\n  B();\n};\ntest();\n```\n分别按入口打包：\n```js\nentry: {\n    index: \"./src/bundle-test/index.js\",\n    a: \"./src/bundle-test/a.js\",\n  }, // 入口文件\n  output: {\n    filename: \"[name].js\", // 出口文件名称\n    libraryTarget: \"umd\", //在 AMD 或 CommonJS require 之后可访问\n    path: path.resolve(__dirname, \"lib\"), // 定义出口文件夹目录\n  },\n```\n优化前：\n![](http://qiniu.js-5.com/%E4%BC%98%E5%8C%96%E5%89%8D.png)\n\n我们使用webpack的splitChunks规则，使得公共模块抽离出来\n在webpack.config.js下配置：\n```js\noptimization: {\n    minimize: false,\n    // 抽离公共文件\n    splitChunks: {\n      minSize: 30, // 打包的最小大小\n      cacheGroups: {\n        default: {\n          name: \"common\",\n          chunks: \"initial\",\n          minChunks: 2, //模块被引用2次以上的才抽离\n          priority: 1, // 越大越优先\n        },\n      },\n    },\n  },\n```\n优化后：\n![](http://qiniu.js-5.com/%E4%BC%98%E5%8C%96%E5%90%8E.png)\n\n可以看到，优化后打包大小几乎减小了一半。","tags":["js","webpack"]},{"title":"双指针相关算法","url":"/2021/05/10/双指针相关算法/","content":"\n## 概述\n\n讨论一下数组中的双指针相关算法\n\n## 移除元素\n\n### 描述\n\n给你一个数组 nums  和一个值 val，你需要 原地 移除所有数值等于  val  的元素，并返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n### 实现\n\n#### 冒泡版\n\n最初想到的这个有点像冒泡排序，即把需要删除的元素全部往数组后面排，再单独找出新数组长度。该方式简单粗暴，比较容易想到，但是时间复杂度为 O(n^2)，实现为下：\n\n```js\nremoveElement1(nums, val) {\n      let flagValue = null;\n      let num = 0;\n      for (let i = 0; i < nums.length; i++) {\n        for (let j = 0; j < nums.length - 1 - i; j++) {\n          if (nums[j] === val) {\n            flagValue = nums[j];\n            nums[j] = nums[j + 1];\n            nums[j + 1] = flagValue;\n          }\n        }\n      }\n      for (let k = 0; k < nums.length; k++) {\n        if (nums[k] !== val) {\n          num++;\n        }\n      }\n      return num;\n    },\n```\n\n#### 优化版\n\n由于上面代码循环太多次，涉及到 3 个 for 循环，实际运行效率非常低，优化为下：\n\n```js\nremoveElement2(nums, val) {\n      let size = nums.length;\n      for (let i = 0; i < size; i++) {\n        if (nums[i] === val) {\n          for (let k = i; k < size - 1; k++) {\n            nums[k] = nums[k + 1];\n          }\n          i--;\n          size--;\n        }\n      }\n      return size;\n    },\n```\n\n#### 双指针版\n\n上面的版本时间复杂度依然没有满足要求，最后采用双指针法，解决该问题：\n\n```js\nremoveElement3(nums, val) {\n      let flag = 0;\n      for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== val) {\n          nums[flag] = nums[i];\n          flag++;\n        }\n      }\n      return flag;\n    }\n```\n\n双指针法代码简洁优美，时间复杂度为 O(n)，比最初自己写的版本不知高到哪里去了...\n\n我太菜了。\n\n[算法地址](https://leetcode-cn.com/problems/remove-element/)\n\n## 移除元素\n\n给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。\n\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n\n[算法地址](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)\n\n该题解法也是双指针方式，代码如下：\n\n```js\nremoveDuplicates(nums) {\n      let flag = 0;\n      for (let i = 1; i <= nums.length; i++) {\n        if (nums[i - 1] !== nums[i]) {\n          nums[flag] = nums[i - 1];\n          flag++;\n        }\n      }\n      return flag;\n    }\n```\n\n双指针方式：设置一个正常的遍历指针，一个慢指针。当满足条件时，把原数组中的元素用慢指针覆盖。这样得出的数组即为所求数组，而慢指针的值，即为新数组的长度，超出该长度的数组空间可以视为垃圾数据。\n\n## 移动零\n\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n[题目链接](https://leetcode-cn.com/problems/move-zeroes/)\n\n可以先收集非零元素，然后记住非零元素个数（index)，最后把数组剩余空间全部置 0\n\n```js\nmoveZeroes(nums) {\n      // [0,1,0,3,12]\n      let flag = 0;\n      let size = nums.length;\n      for (let i = 0; i < size; i++) {\n        if (nums[i] !== 0) {\n          nums[flag] = nums[i];\n          flag++;\n        }\n      }\n      for (let k = flag; k < size; k++) {\n        nums[k] = 0;\n      }\n      return flag;\n    },\n```\n\n上面的解法还是不大简洁，看看大佬写的：\n\n```js\nmoveZeroes(nums) {\n      // [0,1,0,3,12]\n      let flag = 0;\n      let size = nums.length;\n      for (let i = 0; i < size; i++) {\n        if (nums[i] !== 0) {\n          nums[flag++] = nums[i];\n        }\n      }\n      while (flag < size) {\n        nums[flag++] = 0;\n      }\n      return nums;\n    },\n```\n\n果然大佬还是太强了...\n\n## 比较含退格的字符串\n\n给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。\n\n注意：如果对空文本输入退格字符，文本继续为空。\n\n[题目链接](https://leetcode-cn.com/problems/backspace-string-compare/)\n\n基本思路：把字符串转换为数组，然后使用双指针方法，设置一个慢指针，遍历数组；当检测到#号时，慢指针-1，并且使得数组中慢指针对应的空间存储对应值。\n\n```js\nbackspaceCompare(s, t) {\n      const formatString = (string) => {\n        let list = string.split(\"\");\n        // [a,b,#,c]\n        let flag = 0;\n        let size = list.length;\n        for (let i = 0; i < size; i++) {\n          if (list[i] !== \"#\") {\n            list[flag++] = list[i];\n          } else {\n            if (flag > 0) {\n              flag--;\n            }\n          }\n        }\n        let newStr = \"\";\n        for (let i = 0; i < flag; i++) {\n          newStr = newStr + list[i];\n        }\n        return newStr;\n      };\n      let newS = formatString(s);\n      let newT = formatString(t);\n      return newS === newT;\n    }\n```\n\n该算法时间复杂度为 O(n),空间复杂度为 O(n)\n\n该算法还有实现方式为 O(1)的实现思路\n\n准备两个指针 ii, jj 分别指向 SS，TT 的末位字符，再准备两个变量 skipSskipS，skipTskipT 来分别存放 SS，TT 字符串中的 # 数量。\n从后往前遍历 SS，所遇情况有三，如下所示：\n\n2.1 若当前字符是 #，则 skipSskipS 自增 11；\n\n2.2 若当前字符不是 #，且 skipSskipS 不为 00，则 skipSskipS 自减 11；\n\n2.3 若当前字符不是 #，且 skipSskipS 为 00，则代表当前字符不会被消除，我们可以用来和 TT 中的当前字符作比较。\n\n若对比过程出现 SS, TT 当前字符不匹配，则遍历结束，返回 falsefalse，若 SS，TT 都遍历结束，且都能一一匹配，则返回 truetrue。\n\n```js\nvar backspaceCompare = function (S, T) {\n  let i = S.length - 1,\n    j = T.length - 1,\n    skipS = 0,\n    skipT = 0;\n  // 大循环\n  while (i >= 0 || j >= 0) {\n    // S 循环\n    while (i >= 0) {\n      if (S[i] === \"#\") {\n        skipS++;\n        i--;\n      } else if (skipS > 0) {\n        skipS--;\n        i--;\n      } else break;\n    }\n    // T 循环\n    while (j >= 0) {\n      if (T[j] === \"#\") {\n        skipT++;\n        j--;\n      } else if (skipT > 0) {\n        skipT--;\n        j--;\n      } else break;\n    }\n    if (S[i] !== T[j]) return false;\n    i--;\n    j--;\n  }\n  return true;\n};\n```\n","tags":["js"]},{"title":"二分法相关算法","url":"/2021/05/10/二分法相关算法/","content":"\n## 概述\n\n讨论一下关于数组的简单算法\n\n## 二分查找\n\n二分查找主要点在于边界条件判断，即结束 while 循环的时机。\n\n当判断左边界大于右边界时，即可确定数组内没有要查找的元素，即可跳出循环体。\n\n```js\n/**\n* nums 检索数组\n* target 检索值\n*/\nsearch(nums, target) {\n  let left = 0,\n    right = nums.length - 1;\n  while (left <= right) {\n    let middle = Math.floor((left + right) / 2);\n    if (nums[middle] > target) {\n      right = middle - 1;\n    } else if (nums[middle] < target) {\n      left = middle + 1;\n    } else {\n      return middle;\n    }\n  }\n  return -1;\n}\n```\n\n[算法地址](https://leetcode-cn.com/problems/binary-search/)\n\n## 查找索引\n\n题目描述：\n\n给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n\n如果数组中不存在目标值 target，返回  [-1, -1]\n\n[算法地址](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\n该问题可以直接简单粗暴的循环两遍，得到左索引和右索引，时间复杂度为 O(n)；但是题目明显是需要更快的时间复杂度，而涉及到排序好的数组操作，优先考虑二分法，用来达到 O(logn)的时间复杂度。\n\n二分法查找开始位置和结束位置，首先查找开始位置，用条件不断逼近左值，得到左值后在其基础上逼近右值（需要重新设置右值为数组最大长度）。\n\n```js\nsearchRange(nums, target) {\n      let left = 0,\n        right = nums.length - 1,\n        res = [-1, -1];\n      while (left < right) {\n        let mid = Math.floor((left + right) / 2);\n        if (nums[mid] >= target) {\n          right = mid;\n        } else {\n          left = mid + 1;\n        }\n      }\n      if (nums[left] !== target) {\n        return res;\n      } else {\n        res[0] = left;\n      }\n      right = nums.length;\n      while (left < right) {\n        let mid = Math.floor((left + right) / 2);\n        if (nums[mid] <= target) {\n          left = mid + 1;\n        } else {\n          right = mid;\n        }\n      }\n      res[1] = left - 1;\n      return res;\n    }\n```\n\n二分法难点主要在边界判断条件的寻找，在上例中，边界条件需要满足两个基本条件：\n\n1.循环最后能退出\n2.left 和 right 最后能达到相邻比较程度，需要能覆盖全数组元素\n\n边界判断的难点主要有： 1.起始值和结束值的验证\n\n所以我个人感觉如果写不出很好的边界判断条件的话，优先判断起始值和结束值的情况，可能也是一种行之有效的方案\n\n（算法果然还是太难了...\n\n## 求平方根\n\n#### 描述\n\n实现  int sqrt(int x)  函数。\n\n计算并返回  x  的平方根，其中  x 是非负整数。\n\n由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。\n\n[69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)\n\n#### 分析\n\nx 的平方根一定是在 0-x 的区间内，所以我们可以使得 left=0，right=x，使用二分法去逼近 x^1/2\n\n每次判断条件即 mid\\*mid 和 x 的比较大小\n\n#### 解题\n\n方法一：\n\n```js\nmySqrt(x) {\n      let left = 0,\n        right = x;\n      while (left <= right) {\n        let mid = Math.floor((left + right) / 2);\n        if (mid * mid < x) {\n          left = mid + 1;\n        } else if (mid * mid > x) {\n          right = mid - 1;\n        } else if (mid * mid === x) {\n          return mid;\n        }\n      }\n      return right;\n    }\n```\n\n方法二：\n\n```js\nmySqrt(x) {\n      let left = 0,\n        right = x + 1;\n      while (left < right) {\n        let mid = Math.floor((left + right) / 2);\n        if (mid * mid < x) {\n          left = mid + 1;\n        } else if (mid * mid > x) {\n          right = mid;\n        } else if (mid * mid === x) {\n          return mid;\n        }\n      }\n      return left - 1;\n    }\n```\n\n## 备注\n\n关于二分法的一些边界判断分析：\n\n[关于二分法的一些分析](https://blog.csdn.net/xiao_jj_jj/article/details/106018702)\n","tags":["js"]},{"title":"常见排序算法","url":"/2021/04/20/常见排序算法/","content":"\n## 概述\n\n一般而言，我们使用插入排序会多一些，在工程上使用的简单的排序算法，基本都是插入排序。数据量大的时候，会把插入排序优化为归并排序，以下主要比较时间复杂度为 O(n^2),空间复杂度为 O(1)的简单排序算法：冒泡排序，选择排序，插入排序。\n\n## 冒泡排序\n\n冒泡排序通过比较相邻的两个数，来达到排序目的\n\n主要分为两层循环，第一层循环表示用来把当前数组中最大的元素排到最后一位，第二层循环用来比较并且交换位置。这是思想最简单的排序算法，可以用以下代码显示：\n\n```js\nbubbleSort(arr) {\n      for (let i = 0; i < arr.length; i++) {\n        for (let j = 0; j < arr.length-1; j++) {\n          if (arr[j] > arr[j + 1]) {\n            let current = arr[j + 1];\n            arr[j + 1] = arr[j];\n            arr[j] = current;\n          }\n        }\n      }\n      return arr;\n    }\n```\n\n由于每次对比后，最大的数总是在最后，该算法可以优化为：\n\n```js\nbubbleSort(arr) {\n      for (let i = 0; i < arr.length; i++) {\n        for (let j = 0; j < arr.length-i-1; j++) {\n          if (arr[j] > arr[j + 1]) {\n            let current = arr[j + 1];\n            arr[j + 1] = arr[j];\n            arr[j] = current;\n          }\n        }\n      }\n      return arr;\n    }\n```\n\n因为每进行一次外层循环，那么就会使得最大的一个数排序到数组最右侧，因此内层循环可以不需要循环“最右侧”已经排序好的数组。\n\n## 选择排序\n\n## 插入排序\n\n插入排序类似于整理扑克牌，在一个乱序数组中，可以分为两个数组，第一个已经排好序，第二个待排序，它们连接在一起共同构成了原数组。我们分别从原数组中拿出一个元素来插入第一个顺序数组中，按次序比较当前元素和已排序数组中元素的大小，满足某种大小关系则把当前元素和之前一个元素调换位置（因为第一个数组和第二个数组是相邻关系，第一个元素最后一个元素与第二个数组第一个元素是相邻关系）\n\n```js\nlet arr = [5, 3, 9, 8, 1, 4, 6]\ninsertionSort(arr) {\n      for (let i = 1; i < arr.length; i++) {\n        let preIndex = i - 1;\n        while (preIndex >= 0 && arr[preIndex + 1] < arr[preIndex]) {\n          let current = arr[preIndex + 1];\n          arr[preIndex + 1] = arr[preIndex];\n          arr[preIndex] = current;\n          preIndex--;\n        }\n      }\n      return arr;\n    }\ninsertionSort(arr)\n// arr = [ 1, 3, 4, 5, 6, 8, 9 ]\n```\n\n## 希尔排序\n\n## 总结\n\n一般来讲，插入排序在实际应用中，性能会优于冒泡排序，不仅仅是因为插入排序会少很多循环过程，还因为插入排序不会那么频繁的进行数据顺序交换。插入排序通过判断数据大小后，每次循环中数据交换只会有一次；而冒泡排序数据交换会有 n-1 次。因此从各方面来讲，冒泡排序都不会快于插入排序。\n\n## 参考资料\n\nhttps://zhuanlan.zhihu.com/p/40695917\n","tags":["js"]},{"title":"vue源码分析","url":"/2021/04/07/vue源码分析/","content":"\n# 调试环境搭建\n\n首先 clone vue 项目：https://github.com/vuejs/vue.git\n\n然后在源码目录中找到 package.json，在 scripts 下，修改 dev 为：`\"dev\": \"rollup -w -c scripts/config.js --environment TARGET:web-full-dev --sourcemap\"`，为 dev 下编译的代码设置 sourcemap，用来断点调试源码。\n\n执行`npm run dev`，这样会在 dist 目录下编译出一个`vue.js`文件，同时会编译出一个对应的 sourcemap 文件。我们即可用该`vue.js`文件调试。（需要注意的是，vue 项目使用 rollup 打包，可能需要先全局安装 rollup：`cnpm i rollup -g `)\n\n然后在根目录下 examples 文件夹下新建一个 index.html，并引用我们新编译的 vue.js 文件\n\n```html\n<html>\n  <header>\n    <script src=\"../dist/vue.js\"></script>\n  </header>\n  <body>\n    <div id=\"app\"></div>\n    <script>\n      new Vue({\n        el: \"#app\",\n        template: \"<div>Hello World</div>\",\n      });\n    </script>\n  </body>\n</html>\n```\n\n现在即可在该 index.html 文件中调试代码\n\n# 构建主流程分析\n\n# 核心过程分析\n\n## 变化检测\n\n## 虚拟 dom\n\n## 模板编译\n\n## 生命周期\n\n## 参考资料\n\n[理解 vue 实现原理，实现一个简单的 Vue 框架](https://blog.csdn.net/pur_e/article/details/53066275)\n\n[剖析 Vue 实现原理 - 如何实现双向绑定 mvvm](\"https://github.com/DMQ/mvvm\")\n\n[Vue.js 源码（1）：Hello World 的背后](https://segmentfault.com/a/1190000006866881)\n","tags":["js","vue"]},{"title":"webpack5+vue2打包实践2","url":"/2021/03/30/webpack5+vue2打包实践2/","content":"\n## 集成 vue\n\n### 拆分 webpack 配置\n\n由于我们要在环境中集成 vue，需要在本地进行调试 vue 代码，所以我们至少需要两套环境，一套 dev 配置，用来打开一个本地服务器；一套 prod 配置，用来打包 labreries，我们引入`webpack-merge`包，来拆分 webpack 配置。\n\n`webpack.common.js`文件用来存放 dev 和 prod 共同存在的配置\n\n`webpack.dev.js`用来存放 development 环境的配置\n\n`webpack.prod.js`用来存放 production 环境配置\n\n我们把`webpack.config.js`文件直接变为`webpack.prod.js`，然后在其中通过 webpack-merge 包，合并 common 与 prod 文件中的 webpack 配置：\n\n```js\nconst path = require(\"path\");\nconst { merge } = require(\"webpack-merge\");\nconst common = require(\"./webpack.common\");\n\nprod = {\n  mode: \"production\", // 选择模式为生产\n  entry: \"./src/yn-chart-middleware/index.js\", // 入口文件\n  output: {\n    filename: \"ynChartMiddleware.js\", // 出口文件名称\n    library: \"ynChartMiddleware\", // library暴露出来的名称\n    libraryTarget: \"umd\", //在 AMD 或 CommonJS require 之后可访问\n    path: path.resolve(__dirname, \"lib\"), // 定义出口文件夹目录\n  },\n  // 打包代码不压缩\n  optimization: {\n    minimize: true,\n  },\n  target: [\"web\", \"es5\"],\n  module: {\n    rules: [\n      {\n        test: /\\.m?js$/,\n        exclude: /(node_modules|bower_components)/,\n        use: {\n          loader: \"babel-loader\",\n        },\n      },\n    ],\n  },\n  // 把以下依赖不打入包中，让包文件去外部宿主中引入这些依赖\n  externals: {\n    echarts: {\n      commonjs: \"echarts\",\n      commonjs2: \"echarts\",\n      amd: \"echarts\",\n      root: \"_\",\n    },\n  },\n};\n\nmodule.exports = merge(common, prod);\n```\n\n`webpack.common.js`文件可以暂时置空：\n\n```js\nmodule.exports = {};\n```\n\n`webpack.dev.js`文件可以由`webpack.prod.js`文件复制得到；\n\n然后我们使用`webpack-dev-server`包，用来在本地启动一个服务器调试环境。\n\n修改 package.json：\n\n```js\n\"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"build\": \"webpack --config webpack.prod.js\",\n    \"serve\": \"webpack serve --open --config webpack.dev.js\"\n  },\n```\n\n现在执行 `npm run serve`，即可打开一个本地服务。\n\n如图：\n\n![](http://qiniu.js-5.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210329212507.png)\n\n由于当前未定义入口文件，所以本地服务器默认显示出了根目录下文件\n\n### 配置开发环境 webpack\n\n在通过 webpack-dev-server 包启动本地服务的时候，我们必须定义一个 html 的模板文件，用来将打包后的脚本引用添加到 html 文件中，为了方便，我们引入`html-webpack-plugin`包，为 webpack 自动集成 html 模板。同时，我们为 dev 下定义入口文件和出口文件，入口文件会被打包成 output.filename 定义的 js，自动被引用到`html-webpack-plugin`生成的 html 模板中。\n\n```js\nconst path = require(\"path\");\nconst { merge } = require(\"webpack-merge\");\nconst common = require(\"./webpack.common\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nconst dev = {\n  mode: \"development\", // 选择模式为生产\n  entry: \"./src/index.js\", // 入口文件\n  output: {\n    filename: \"[name].bundle.js\",\n    path: path.resolve(__dirname, \"dist\"), // 定义出口文件夹目录\n  },\n  devServer: {\n    contentBase: path.join(__dirname, \"dist\"),\n  },\n  // 打包代码不压缩\n  optimization: {\n    minimize: false,\n  },\n  target: [\"web\", \"es5\"],\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname, \"public/index.html\"), // 根据public/index.html文件生成模板\n    }),\n  ],\n};\n\nmodule.exports = merge(common, dev);\n```\n\n这里解释一下`path.resolve()`方法，path 是 node 原生提供的模块，该方法根据运行环境不同会有不同的表现。`path.resolve()`会把参数中的路径合并成一个绝对路径，`__dirname`会获得当前执行文件所在目录的完整目录名，`path.resolve(__dirname, \"public/index.html\")`会获取当前执行文件同级目录下 public 文件夹下 index.html 文件。在该项目下，路径会解释为`/public/index.html`\n\n如果我们在 public 下定义的 index.html 文件为：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <div id=\"app\">hello</div>\n  </body>\n</html>\n```\n\n那么当我们执行`npm run serve`后，可以得到：\n\n![](http://qiniu.js-5.com/web-server.png)\n\n### 集成 vue\n\n在 webpack 中使用 vue，需要用到两个包： `vue-loader`,`vue-template-compiler`,其中`vue-loader`用来转换 vue 的单文件语法，可以用来解析`.vue`格式文件，`vue-template-compiler`用来编译模板为渲染函数（template => ast => render）\n\n```js\nconst path = require(\"path\");\nconst { merge } = require(\"webpack-merge\");\nconst common = require(\"./webpack.common\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nconst { VueLoaderPlugin } = require(\"vue-loader\");\n\nconst dev = {\n  mode: \"development\", // 选择模式为生产\n  entry: \"./src/main.js\", // 入口文件\n  output: {\n    filename: \"[name].bundle.js\",\n    path: path.resolve(__dirname, \"dist\"), // 定义出口文件夹目录\n  },\n  devServer: {\n    contentBase: path.join(__dirname, \"dist\"),\n  },\n  // 打包代码不压缩\n  optimization: {\n    minimize: false,\n  },\n  target: [\"web\", \"es5\"],\n  module: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        use: {\n          loader: \"vue-loader\",\n        },\n      },\n    ],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname, \"public/index.html\"),\n    }),\n    new VueLoaderPlugin(),\n  ],\n};\n\nmodule.exports = merge(common, dev);\n```\n\n然后我们在 src 中定义 vue 入口\n\n新建`src/main.js`，`src/App.vue`文件\n\n```js\nimport Vue from \"vue\";\nimport App from \"./App.vue\";\n\nnew Vue({\n  render: (c) => c(App),\n}).$mount(\"#app\");\n```\n\n```js\n<template>\n  <div>hello</div>\n</template>\n<script>\nexport default {\n  data() {\n    return {};\n  },\n};\n</script>\n<style scoped></style>\n\n```\n\n然后在 webpack 中定义入口文件为`src/main.js`，运行`npm run serve`即可看到 vue 文件被正确解析。\n\n最后的 package.json:\n\n```js\n{\n  \"name\": \"test\",\n  \"version\": \"1.0.0\",\n  \"description\": \"test\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"lib\"\n  ],\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"build\": \"webpack --config webpack.prod.js\",\n    \"serve\": \"webpack serve --open --config webpack.dev.js\",\n    \"dist\": \"webpack --config webpack.dev.js\"\n  },\n  \"keywords\": [\n    \"test\"\n  ],\n  \"author\": \"guan\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.13.8\",\n    \"@babel/preset-env\": \"^7.13.9\",\n    \"babel-loader\": \"^8.2.2\",\n    \"core-js\": \"^3.9.1\",\n    \"html-webpack-plugin\": \"^5.3.1\",\n    \"vue-loader\": \"^15.9.6\",\n    \"vue-template-compiler\": \"^2.6.12\",\n    \"webpack\": \"^5.24.3\",\n    \"webpack-cli\": \"^4.5.0\",\n    \"webpack-dev-server\": \"^3.11.2\",\n    \"webpack-merge\": \"^5.7.3\"\n  },\n  \"dependencies\": {\n    \"echarts\": \"^5.0.2\",\n    \"number-precision\": \"^1.5.0\",\n    \"vue\": \"^2.6.12\"\n  }\n}\n\n```\n\n## 参考资料\n\n[webpack 手册](https://webpack.docschina.org/guides/production/)\n","tags":["js","vue","webpack"]},{"title":"webpack5+vue2打包实践","url":"/2021/03/04/webpack5+vue2打包实践/","content":"\n## 背景\n\n在图转换中间件的开发过程中，需要准备一个开发测试打包一体化环境，该环境至少需要把开发好的中间件代码打包，并上传到我们的私有 npm 仓库中。\n\n中间件代码如下：\n\n<img src=\"http://qiniu.js-5.com/%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%BB%93%E6%9E%84.png\" width=\"250px\" height=\"270px\">\n\n## 准备过程\n\n由于之前的开发测试环境有太多无关代码，现在准备自己重新着手搭建一个纯净的打包环境。优先实现 library（即中间件源码） 文件打包并上传到 npm 中；其次实现本地启动 webpack server，用来作为开发环境调试代码服务器；再次实现本地 vue 项目打包，并放在服务器中可用\n\n## 创建项目\n\n新建一个项目文件夹，起名 test，然后在当前项目目录运行\n\n```js\nnpm init\n```\n\n可以看到当前生成了一个 package.json 文件\n\n然后在当前目录中新建 src 文件夹，用来存放项目代码。并把我们的中间件文件放入其中。现在文件目录是这样的：\n\n<img src=\"http://qiniu.js-5.com/%E5%88%9D%E5%A7%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png\" style=\"max-width:100%\">\n\n## 集成 webpack\n\n### 安装\n\n我们需要把中间件代码打包成一个文件，方便压缩代码和引用等。现在引入 webpack 作为打包工具。由于现在 webpack5 比较新，我们直接安装 webpack5\n\n```js\nnpm install webpack@5 --save-dev\n```\n\n当前初始的 package.json 文件是这样的\n\n```js\n{\n  \"name\": \"test\",\n  \"version\": \"1.0.0\",\n  \"description\": \"test\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [\n    \"test\"\n  ],\n  \"author\": \"guan\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"webpack\": \"^5.24.3\"\n  }\n}\n\n```\n\n### 使用\n\n我们利用 webpack 文件，把一些基本的 webpack 配置写在文件里，然后通过 package.json 中的命令行执行 webpack 命令。\n\n为了试验，我们在 src 目录下新建 index.js 文件，输入测试代码：\n\n```js\nconst test = () => {\n  console.log(\"hello webpack!\");\n};\nexport { test };\n```\n\n在根目录下新建 webpack.config.js 文件，输入以下代码：\n\n```js\nconst path = require(\"path\");\n\nmodule.exports = {\n  mode: \"production\", // 选择模式为生产\n  entry: \"./src/index.js\", // 入口文件\n  output: {\n    filename: \"main.js\", // 出口文件名称\n    library: \"ynChartMiddleware\", // library暴露出来的名称\n    libraryTarget: \"umd\", //在 AMD 或 CommonJS require 之后可访问\n    path: path.resolve(__dirname, \"lib\"),\n  },\n  // 打包代码不压缩\n  optimization: {\n    minimize: false,\n  },\n};\n```\n\n然后在 package.json scripts 字段下加入以下命令：\n\n```js\n    \"build\": \"webpack --config webpack.config.js\"\n```\n\n现在在控制台执行命令：\n\n```js\nnpm run build\n```\n\n控制台报错：\n\n```js\nCLI for webpack must be installed.\n  webpack-cli (https://github.com/webpack/webpack-cli)\n\nWe will use \"npm\" to install the CLI via \"npm install -D webpack-cli\".\nDo you want to install 'webpack-cli' (yes/no):\n```\n\n因为我们想要使用命令行方式调用 webpack 需要首先安装 webpack-cli，所以我们选择安装；再次执行打包命令后得到目标文件（lib/main.js）代码:\n\n```js\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === \"object\" && typeof module === \"object\")\n    module.exports = factory();\n  else if (typeof define === \"function\" && define.amd) define([], factory);\n  else if (typeof exports === \"object\")\n    exports[\"ynChartMiddleware\"] = factory();\n  else root[\"ynChartMiddleware\"] = factory();\n})(self, function () {\n  return /******/ (() => {\n    // webpackBootstrap\n    /******/ \"use strict\"; // The require scope\n   ...\n   // 中间部分省略\n   ...\n    var __webpack_exports__ = {};\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export */ __webpack_require__.d(__webpack_exports__, {\n      /* harmony export */ test: () => /* binding */ test,\n      /* harmony export */\n    });\n    const test = () => {\n      console.log(\"hello webpack!\");\n    };\n\n    /******/ return __webpack_exports__;\n    /******/\n  })();\n});\n```\n\n当前文件目录结构：\n\n<img src=\"http://qiniu.js-5.com/%E6%89%93%E5%8C%85%E6%B5%8B%E8%AF%95.png\" style=\"max-width:100%\">\n\n上图可以看到，我们确实把 src/index.js 文件代码打包成了 lib/main.js\n\n## ES6 转 ES5\n\n在上面的实践中，我们可以看到，虽然我们实现了模块化打包，但是我们发现 webpack 并没有自动进行代码版本转换。\n\n原代码：\n\n```js\nconst test = () => {\n  console.log(\"hello webpack!\");\n};\nexport { test };\n```\n\n打包后：\n\n```js\nreturn /******/ (() => {\n  // webpackBootstrap\n  /******/ \"use strict\"; // The require scope\n  /******/ /******/ var __webpack_require__ = {}; /* webpack/runtime/define property getters */\n  /******/\n  /************************************************************************/\n  /******/ /******/ (() => {\n    /******/ // define getter functions for harmony exports\n    /******/ __webpack_require__.d = (exports, definition) => {\n      /******/ for (var key in definition) {\n        /******/ if (\n          __webpack_require__.o(definition, key) &&\n          !__webpack_require__.o(exports, key)\n        ) {\n          /******/ Object.defineProperty(exports, key, {\n            enumerable: true,\n            get: definition[key],\n          });\n          /******/\n        }\n        /******/\n      }\n      /******/\n    };\n    /******/\n  })(); /* webpack/runtime/hasOwnProperty shorthand */\n  /******/\n  /******/ /******/ (() => {\n    /******/ __webpack_require__.o = (obj, prop) =>\n      Object.prototype.hasOwnProperty.call(obj, prop);\n    /******/\n  })(); /* webpack/runtime/make namespace object */\n  /******/\n  /******/ /******/ (() => {\n    /******/ // define __esModule on exports\n    /******/ __webpack_require__.r = (exports) => {\n      /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n        /******/ Object.defineProperty(exports, Symbol.toStringTag, {\n          value: \"Module\",\n        });\n        /******/\n      }\n      /******/ Object.defineProperty(exports, \"__esModule\", { value: true });\n      /******/\n    };\n    /******/\n  })();\n  /******/\n  /************************************************************************/\n  var __webpack_exports__ = {};\n  __webpack_require__.r(__webpack_exports__);\n  /* harmony export */ __webpack_require__.d(__webpack_exports__, {\n    /* harmony export */ test: () => /* binding */ test,\n    /* harmony export */\n  });\n  const test = () => {\n    console.log(\"hello webpack!\");\n  };\n\n  /******/ return __webpack_exports__;\n  /******/\n})();\n```\n\n这样的代码在 ie11 中无法运行，我们得把 es6 语法编译为 es5。\n\n首先我们把 webpack 自己生成的打包代码变为 es5，这需要再 webpack.config.js 中配置参数：\n\n```js\ntarget: [\"web\", \"es5\"],\n```\n\n该参数意思是打包时编译为类浏览器环境，并按 es5 的风格进行打包。但是这样只会改变 webpack 默认的打包代码，而我们自己的代码任然不会被转码。\n\n因此我们需要引入 babel，来转码我们的 js 文件。先在 webpack 中添加 babel 规则，可以正则检测文件。也可以认为，在 webpack 中使用 babel 就需要使用 babel-loader 来作为连接纽带，用来编译目标文件代码：\n\n```js\nmodule: {\n    rules: [\n      {\n        test: /\\.m?js$/,\n        exclude: /(node_modules)/,\n        use: {\n          loader: \"babel-loader\",\n        },\n      },\n    ],\n  },\n```\n\n我们需要安装 babel-loader 包和 @babel/core 包，并且需要在根目录创建一个 babel 配置文件，文件名为\".babelrc\"，该文件用来告诉 babel 应该如何转码文件，该文件配置如下：\n\n```js\n{\n    \"presets\": [\n        [\n            \"@babel/preset-env\",\n            {\n                \"useBuiltIns\": \"usage\",\n                \"modules\": false,\n                \"corejs\": {\n                    \"version\": 3\n                },\n                \"targets\": {\n                    \"ie\": \"11\"\n                }\n            }\n        ]\n    ]\n}\n```\n\n该文件主要定义了输出的代码版本，以上用到了 @babel/preset-env 用来转换代码，所以我们需要安装它。\n\n现在我们再次执行 build 命令，得到如下编译过后的代码：\n\n```js\nreturn /******/ (function () {\n  // webpackBootstrap\n  /******/ \"use strict\"; // The require scope\n  /******/ /******/ var __webpack_require__ = {}; /* webpack/runtime/define property getters */\n  /******/\n  /************************************************************************/\n  /******/ /******/ !(function () {\n    /******/ // define getter functions for harmony exports\n    /******/ __webpack_require__.d = function (exports, definition) {\n      /******/ for (var key in definition) {\n        /******/ if (\n          __webpack_require__.o(definition, key) &&\n          !__webpack_require__.o(exports, key)\n        ) {\n          /******/ Object.defineProperty(exports, key, {\n            enumerable: true,\n            get: definition[key],\n          });\n          /******/\n        }\n        /******/\n      }\n      /******/\n    };\n    /******/\n  })(); /* webpack/runtime/hasOwnProperty shorthand */\n  /******/\n  /******/ /******/ !(function () {\n    /******/ __webpack_require__.o = function (obj, prop) {\n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    };\n    /******/\n  })(); /* webpack/runtime/make namespace object */\n  /******/\n  /******/ /******/ !(function () {\n    /******/ // define __esModule on exports\n    /******/ __webpack_require__.r = function (exports) {\n      /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n        /******/ Object.defineProperty(exports, Symbol.toStringTag, {\n          value: \"Module\",\n        });\n        /******/\n      }\n      /******/ Object.defineProperty(exports, \"__esModule\", { value: true });\n      /******/\n    };\n    /******/\n  })();\n  /******/\n  /************************************************************************/\n  var __webpack_exports__ = {};\n  __webpack_require__.r(__webpack_exports__);\n  /* harmony export */ __webpack_require__.d(__webpack_exports__, {\n    /* harmony export */ test: function () {\n      return /* binding */ test;\n    },\n    /* harmony export */\n  });\n  var test = function test() {\n    console.log(\"hello webpack!\");\n  };\n\n  /******/ return __webpack_exports__;\n  /******/\n})();\n```\n\n可以看到，我们的代码已经正确的转换了箭头函数，已经把 es6 风格的代码转换成了 es5\n\n综上所述，babel 用来转换代码版本，需要 3 个包：@babel/core babel-loader @babel/preset-env\n\n## 打包中间件\n\n### 打包\n\n现在我们已经用测试文件做好了前期准备，现在我们把 webpack.config.js 中的入口文件改为中间件文件，然后出口文件名改为中间件名。\n\n可以看到报了如下错误：\n\n<img src=\"http://qiniu.js-5.com/corejs%E6%8A%A5%E9%94%99.png\" style=\"max-width:100%\">\n\n这提示我们没有安装 core-js 模块，无法找到对应的转换方法。执行：\n\n```js\ncnpm install core-js --save-dev\n```\n\n再重现 build，发现中间件中使用了 echarts，而我们也需要安装一下 echarts 包；当所有需要用到的包全部安装完毕后，我们可以看到，打包成功了。\n\n### 优化打包大小\n\n我们查看打包文件，代码风格是我们需要的 es5，但是打包文件有 3.5M，这明显太大了，我们需要减小大小。\n\n首先第一步是代码压缩，压缩后大小从 3.5M 变为了 0.9M，明显还是太大了。\n\n我们思考是不是可以不要打包某些包进中间件，比如 echarts。因为中间件宿主环境，也一定会引入 echarts，所以 echarts 可以不用打包进中间件。我们在 webpack 配置文件中加入以下代码：\n\n```js\nexternals: {\n    echarts: {\n      commonjs: \"echarts\",\n      commonjs2: \"echarts\",\n      amd: \"echarts\",\n      root: \"_\",\n    },\n  },\n```\n\n重新打包，我们发现包文件已经变为 66KB，相比于之前的 3.5M，已经小非常多了。现在这个库文件，就已经打包完成了。\n\n## 上传 npm\n\n上传到 npm 中时，包名默认 package.json 中的 name 字段，引用路径默认 main 字段。比如我们把 package.json 改为如下，代表我们包名为 yn-chart-middleware，用户下载包后默认会引用“./lib/yn-chart-middleware.js”目录下的文件。\n\n```js\n{\n  \"name\": \"yn-chart-middleware\",\n  \"version\": \"1.0.0\",\n  \"description\": \"test\",\n  \"main\": \"./lib/yn-chart-middleware.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"build\": \"webpack --config webpack.config.js\"\n  },\n  \"keywords\": [\n    \"test\"\n  ],\n  \"author\": \"guan\",\n  \"license\": \"ISC\",\n  ...\n  ...\n}\n\n```\n\n发布包时先使用 npm login 登录 npm，然后 npm publish 即可发布自己的包\n\n注意：内网环境下，需要先切换 npm 源，然后登录内网 npm。之后的操作和 npm 一致\n\n在有时候，我们不希望自己的开发文件，比如 src/目录下的文件被上传到 npm，我们可以选择不上传这部分文件到 npm 上。如下，在 package.json 中增加如下代码：\n\n```js\n\"files\": [\n\t\t\"lib\"\n\t],\n```\n\n表明只把根目录下 lib 文件夹内容上传到 npm\n\n除了上面的白名单模式，还有黑名单模式（及指定不传的文件，上传所有其他文件）\n\n## 配置代码以及目录结构\n\n目录结构：\n\n<img src=\"http://qiniu.js-5.com/%E5%AE%8C%E6%88%90%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png\" style=\"max-width:100%\">\n\n.babelrc 文件：\n\n```js\n{\n    \"presets\": [\n        [\n            \"@babel/preset-env\",\n            {\n                \"useBuiltIns\": \"usage\",\n                \"modules\": false,\n                \"corejs\": {\n                    \"version\": 3\n                },\n                \"targets\": {\n                    \"ie\": \"11\"\n                }\n            }\n        ]\n    ]\n}\n```\n\nwebpack.config.js 文件：\n\n```js\nconst path = require(\"path\");\n\nmodule.exports = {\n  mode: \"production\", // 选择模式为生产\n  entry: \"./src/yn-chart-middleware/index.js\", // 入口文件\n  output: {\n    filename: \"ynChartMiddleware.js\", // 出口文件名称\n    library: \"ynChartMiddleware\", // library暴露出来的名称\n    libraryTarget: \"umd\", //在 AMD 或 CommonJS require 之后可访问\n    path: path.resolve(__dirname, \"lib\"), // 定义出口文件夹目录\n  },\n  // 打包代码不压缩\n  optimization: {\n    minimize: true,\n  },\n  target: [\"web\", \"es5\"],\n  module: {\n    rules: [\n      {\n        test: /\\.m?js$/,\n        exclude: /(node_modules|bower_components)/,\n        use: {\n          loader: \"babel-loader\",\n        },\n      },\n    ],\n  },\n  // 把以下依赖不打入包中，让包文件去外部宿主中引入这些依赖\n  externals: {\n    echarts: {\n      commonjs: \"echarts\",\n      commonjs2: \"echarts\",\n      amd: \"echarts\",\n      root: \"_\",\n    },\n  },\n};\n```\n\npackage.json 文件：\n\n```js\n{\n  \"name\": \"test\",\n  \"version\": \"1.0.0\",\n  \"description\": \"test\",\n  \"main\": \"index.js\",\n  \"files\": [\n\t\t\"lib\"\n\t],\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"build\": \"webpack --config webpack.config.js\"\n  },\n  \"keywords\": [\n    \"test\"\n  ],\n  \"author\": \"guan\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.13.8\",\n    \"@babel/preset-env\": \"^7.13.9\",\n    \"babel-loader\": \"^8.2.2\",\n    \"core-js\": \"^3.9.1\",\n    \"webpack\": \"^5.24.3\",\n    \"webpack-cli\": \"^4.5.0\"\n  },\n  \"dependencies\": {\n    \"echarts\": \"^5.0.2\",\n    \"number-precision\": \"^1.5.0\"\n  }\n}\n\n```\n\n## 参考资料\n\n[webpack 手册](https://webpack.docschina.org/guides/production/)\n","tags":["js","vue","webpack"]},{"title":"js浮点数运算精度问题","url":"/2020/08/14/js浮点数运算精度问题/","content":"\n## 问题提出\n\n```js\n10.23 + 0.2345;\n0.1 + 0.2;\n```\n\n10.23 + 0.2345 实际测试结果为`10.464500000000001`,而不是`10.4645`\n0.1 +0.2 实际测试结果为`0.30000000000000004`,而不是`0.3`\n\n## 原因\n\n浮点数在 2 进制中存储的时候，无法精确存储\n\njs 在数据存储中采用 64 位双精度浮点数形式储存\n\n## 整数转为 2 进制\n\n用 8 位 2 进制表达 10 进制下的数字 8\n\n```js\n8/2 = 4 => 0\n4/2 = 2 => 0\n2/2 = 1 => 0\n1/2 = 0 => 1\n```\n\n商为 0 终止计算，然后倒排为 1000，因为是 8 位，所以在上 4 位补 0\n表达即为：00001000\n\n## 浮点数转换为 2 进制\n\n例如 0.82 的二进制表达为：\n\n```js\n0.82 _ 2 = 1.64 => 1\n0.64 _ 2 = 1.28 => 1\n0.28 _ 2 = 0.56 => 0\n0.56 _ 2 = 1.12 => 1\n0.12 _ 2 = 0.24 => 0\n0.24 _ 2 = 0.48 => 0\n0.48 _ 2 = 0.96 => 0\n0.96 _ 2 = 1.92 => 1\n```\n\n表达即为：0.11010001...\n\n举例：10 进制下 0.1 表达为二进制下为：0.000110011...\n\n## 浮点数在 64 位双精度下的存储\n\n符号位 S：第 1 位是正负数符号位（sign），0 代表正数，1 代表负数\n\n指数位 E：中间的 11 位存储指数（exponent），用来表示次方数\n\n尾数位 M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零\n\n![](https://camo.githubusercontent.com/af8c1cdd9aedced18be47e40d27208b671b4a18d/687474703a2f2f617461322d696d672e636e2d68616e677a686f752e696d672d7075622e616c6979756e2d696e632e636f6d2f37323637613538623239383932633362373233653364366333663733393035612e706e67)\n\n公式表示：\n\n![](https://user-images.githubusercontent.com/948896/31601625-1f199ad0-b220-11e7-9d46-bb48a470bedf.png)\n\n以上的公式遵循科学计数法的规范，在十进制是为 0<M<10，到二进行就是 0<M<2。也就是说整数部分只能是 1，所以可以被舍去，只保留后面的小数部分。如 4.5 转换成二进制就是 100.1，科学计数法表示是 1.001\\*2^2，舍去 1 后 M = 001。E 是一个无符号整数，因为长度是 11 位，取值范围是 0~2047。但是科学计数法中的指数是可以为负数的，所以再减去一个中间数 1023，[0,1022]表示为负，[1024,2047] 表示为正。如 4.5 的指数 E = 1025，尾数 M 为 001\n\n![](https://user-images.githubusercontent.com/948896/31601584-f65ed43e-b21f-11e7-8755-c99b48e5134c.png)\n\n0.1 转成二进制表示为 0.0001100110011001100(1100 循环)，1.100110011001100x2^-4，所以 E=-4+1023=1019；M 舍去首位的 1，得到 100110011...\n\n0.1 +0.2\n\n```js\n// 0.1 和 0.2 都转化成二进制后再进行运算\n0.0001100110011001100110011001100110011001100110011001101 +\n0.001100110011001100110011001100110011001100110011001101 = 0.0100110011001100110011001100110011001100110011001100111;\n\n// 转成十进制正好是 0.30000000000000004\n```\n\n## 生产环境中的解决办法\n\nhttps://github.com/dt-fe/number-precision\n","tags":["js"]},{"title":"树遍历","url":"/2020/08/08/树遍历/","content":"\n## js 中关于树的一些操作\n\n### 树的遍历与查找\n\n一般通过递归的方式遍历一颗树\n\n一般遍历一棵树是为了查找里面的元素，比较保险的方法是先遍历树，保存为一个数组，然后再通过 array.find 方法查找元素\n\n```js\n/**\n * 根据id在tree获取相对应的item\n * @param tree 搜索的tree对象，类型{}\n * @param id 需要搜索的item对应的id\n * @memberof TreeSearch\n */\nfindItemInTree = (tree, id) => {\n  let list = [];\n  // 遍历tree，存储到list\n  const loop = (tree) => {\n    if (tree == null) {\n      return;\n    }\n    list.push(tree);\n    if (tree.children && tree.children.length > 0) {\n      for (let i = 0; i < tree.children.length; i++) {\n        loop(tree.children[i]);\n      }\n    }\n  };\n  loop(tree);\n  let item = list.find((listItem) => {\n    return listItem.id === id;\n  });\n  return item;\n};\n```\n\n### 获取元素 path\n\n一般我们还有一个需求，就是获取树的 path\n可以遍历树，存储为一个键值对结构，比如{}或者 map，然后再通过 parentId 直接循环查找，获取 path 数组\n\n```js\n/**\n * 根据id获得item在tree中的路径\n *  @param tree tree对象\n *  @param id item对应的id\n * @memberof TreeSearch\n */\nfindItemPath = (tree, id) => {\n  let listMap = new Map();\n  // 遍历tree，存储到listMap\n  const loop = (tree) => {\n    if (tree == null) {\n      return;\n    }\n    listMap.set(tree.id, tree);\n    if (tree.children && tree.children.length > 0) {\n      for (let i = 0; i < tree.children.length; i++) {\n        loop(tree.children[i]);\n      }\n    }\n  };\n  loop(tree);\n  let path = [];\n  let currentNodeId = id;\n  // 根节点上没有parentId字段，所以直接循环得出path数组\n  while (currentNodeId) {\n    path.unshift(currentNodeId);\n    currentNodeId = listMap.get(currentNodeId).parentId;\n  }\n  return path;\n};\n```\n\n### 树的遍历方式\n\n#### 深度优先\n\n```js\ntest = () => {\n  let tree = {\n    key: 1,\n    value: 1,\n    children: [\n      {\n        key: 2,\n        value: 2,\n        children: [\n          {\n            key: 4,\n            value: 4,\n          },\n          {\n            key: 5,\n            value: 5,\n          },\n        ],\n      },\n      {\n        key: 3,\n        value: 3,\n        children: [\n          {\n            key: 6,\n            value: 6,\n          },\n          {\n            key: 7,\n            value: 7,\n          },\n        ],\n      },\n    ],\n  };\n  console.log(tree, \"tree\");\n  // 递归方式\n  const DFS = (tree) => {\n    let list = [];\n    const loop = (tree) => {\n      list.push(tree);\n      if (tree.children && tree.children.length > 0) {\n        for (let i = 0; i < tree.children.length; i++) {\n          loop(tree.children[i]);\n        }\n      }\n    };\n    loop(tree);\n    return list;\n  };\n  let array = DFS(tree);\n  console.log(array, \"array\");\n};\n```\n\n#### 广度优先\n\n```js\n// 非递归方式\nconst BFS = (tree) => {\n  let list = [];\n  if (tree !== null) {\n    // 借用队列实现，队列先进先出，借用数组模拟队列\n    let queue = [];\n    queue.unshift(tree);\n    while (queue.length !== 0) {\n      let item = queue.shift();\n      list.push(item);\n      let children = item.children;\n      if (children) {\n        for (let i = 0; i < children.length; i++) {\n          queue.push(children[i]);\n        }\n      }\n    }\n  }\n  return list;\n};\n\nlet array2 = BFS(tree);\nconsole.log(array2, \"array2\");\n```\n","tags":["js"]}]